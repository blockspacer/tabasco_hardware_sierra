/*
 *       Copyright (C) 2013-2014 Intel Mobile Communications GmbH
 *
 *            Sec Class: Intel Confidential (IC)
 *
 *
 * This document contains proprietary information belonging to IMC.
 * Design A/S. Passing on and copying of this document, use and communication
 * of its contents is not permitted without prior written authorisation.
 *
 * Description:
 *   <hardcoded file description - the only part to be modified manually!>
 *
 * Revision Information:
 *  $File name:  /msw_tools/FlashTool/libDownloadTool/src/OS_dependent_code/security_if/IFWD_sec_channel.c $
 *  $CC-Version: .../oint_tools_flashtoole2_01/6 $
 *  $Date:       2014-03-13    15:42:19 UTC $
 *   Responsible: bentzen, Hilmar
 *   Comment:
 *     SMS00847521: "Need to remove Lint warnings..."
 */

#define THIS_MODULE MODULE_SEC  //< Runtime verbosity evaluation

/****************************************************************************/
/* INCLUDES                                                                 */
/****************************************************************************/
#include "IFWD_sec_channel.h"
#include "DebugModule.h"

/****************************************************************************/
/* GLOBAL PARAMETERS / DECLARATIONS                                         */
/****************************************************************************/

//Table with certificate TLV, SM Block and offset information
const T_SECCH_CERT_BLK_INFO CERT_BLK_INFO[] =
  {
    //Flash TLV id:     SM block id:            Cert TLV info:
    {MID_DATA,          SM_BLK_IMEI_DATA_MID,   {T_TLV_16_BIT,  MID_GRP_TYPE,   0x0100}} ,
    {RND_DATA,          SM_BLK_RND_CERT_DATA,   {T_TLV_16_BIT,  RND_GRP_TYPE,   0x0100}} ,
    {KEY_SEC_CH_DATA,   SM_BLK_KEY_CERT_DATA,   {T_TLV_32_BIT,  KEY_CERT_ROOT,  0x0000}}
  };
const uint16_t CERT_BLK_INFO_NOF_ELEMENTS = (sizeof(CERT_BLK_INFO)/sizeof(T_SECCH_CERT_BLK_INFO));

//First list element in linked list containing certificates read from file list
T_SECCH_LIST_ELM * cert_list_header = NULL;

//Holds additional options for setup functions
uint32_t glob_options_param = 0;

//Pointer to entire TLV flash structure once generated
uint8_t *glob_all_cert = NULL;

/* SWISTART */
#ifndef SIERRA_CTF
//Pointer to entire TLV flash structure once generated
uint8_t *glob_key_cert = NULL;

//Pointer to secure channel reply package once generated
uint8_t *glob_reply_data = NULL;
#endif /* SIERRA_CTF */
/* SWISTOP */

//Flags for avoiding duplicates
uint8_t mid_cert_present = false, rnd_cert_present = false, key_cert_present = false;

/* SWISTART */
#ifndef SIERRA_CTF
//Keyswap list for key certificate
uint32_t keyswap_list[16] = {
  SM_BLK_IMEI_DATA_STD,
  SM_BLK_IMEI_DATA_MID,
  SM_BLK_RND_CERT_DATA,
  SM_BLK_TICK_SYSTEM_VALID,
  SM_BLK_TICK_SYSTEM_TI,
  SM_BLK_TICK_SYSTEM_BC,
  SM_BLK_TICK_SYSTEM_SM,
  SM_BLK_TICK_SIMLOCK_NO,
  SM_BLK_TICK_SIMLOCK_NS,
  SM_BLK_TICK_SIMLOCK_SP,
  SM_BLK_TICK_SIMLOCK_CP,
  SM_BLK_TICK_SIMLOCK_SM,
  SM_BLK_SIMLOCK_DATA,
  SM_BLK_SECURE_CHANNEL_DATA,
  0,
  0};


/*==========================================================================*/
/*===========================                    ===========================*/
/*======================       DEFAULT RSA KEYS       ======================*/
/*===========================                    ===========================*/
/*==========================================================================*/
uint8_t Sprk1024dev[]=
{
  0x6b,0xea,0x43,0xf6,0x60,0xb1,0x6c,0xc5,0xf1,0x55,0x21,0x35,0x61,0x04,0x50,0x80,
  0xbe,0xf5,0x2e,0xf5,0x01,0x00,0x00,0x00,0xdd,0xcc,0xbb,0xaa,0x00,0x04,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x75,0x3f,0xb0,0x90,0xcb,0xba,0x2a,0xcf,0x01,0x65,0xc4,0x8c,0x90,0x56,0x33,0xa4,
  0x8f,0x44,0xba,0x98,0xd5,0x5c,0x45,0xc2,0xb8,0x64,0x1a,0xdf,0xd6,0x1f,0x0f,0x3b,
  0x69,0x9b,0xad,0xe6,0xc0,0x82,0x62,0x85,0x36,0x80,0x4a,0xa7,0x7b,0xe3,0x96,0xbc,
  0x6e,0xed,0xce,0x7d,0xa1,0xe3,0xa3,0x13,0x5c,0x6d,0xf6,0x66,0xcf,0xe8,0x5e,0x1b,
  0x35,0x74,0xa6,0x8a,0x74,0x72,0x72,0x29,0x97,0x2b,0x0b,0xe4,0x8c,0x2a,0x3a,0x4b,
  0xfa,0xd4,0x95,0x7e,0x5b,0xa3,0x50,0x39,0x05,0xde,0xa1,0x67,0x0a,0x77,0x97,0xc7,
  0x59,0xf5,0xea,0x75,0x8c,0x3a,0xec,0x00,0xa1,0x59,0x6b,0x5e,0xea,0x86,0xdd,0x32,
  0xd4,0x89,0x80,0x41,0x6c,0x90,0x19,0xcb,0x6a,0xc9,0xb8,0x36,0x22,0x77,0xf5,0xa3,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xaf,0xdf,0x88,0xd9,0x31,0x97,0x40,0x36,0x82,0x18,0xa6,0xd2,0xd8,0x81,0x4d,0x76,
  0xd6,0xe7,0x17,0xe5,0x40,0x0a,0x68,0xa4,0x14,0x96,0x28,0x4f,0xc1,0x2e,0x96,0xd9,
  0x1e,0x69,0x84,0xda,0x20,0xc3,0x93,0xc7,0xd1,0xc0,0x6f,0xfb,0x39,0xd5,0x62,0x1a,
  0xa6,0x64,0xb5,0xbc,0x72,0xd5,0x74,0x9d,0x0a,0xa4,0xf1,0x9a,0x37,0xdc,0x8d,0x2a,
  0x78,0x97,0x81,0x13,0x6c,0xe9,0xb4,0xae,0x98,0xbf,0xbf,0x66,0x86,0x66,0xd8,0xd7,
  0x85,0x61,0x29,0xe3,0x1c,0x4a,0x68,0xdb,0xdb,0xea,0x37,0x91,0x56,0x25,0x2c,0xc2,
  0xa8,0x07,0x75,0xe5,0xef,0xac,0xa3,0x07,0x42,0x27,0x60,0xe9,0xdd,0x74,0xaf,0x09,
  0xa0,0xb5,0xe4,0x2b,0xb3,0xd8,0x6d,0x38,0x81,0x7d,0xe8,0xf1,0x4f,0xc6,0x6e,0x31,
  0xab,0x6c,0xc4,0x36,0x9e,0x0d,0xd5,0xf2,0xba,0x05,0x54,0x97,0xb1,0xbe,0x55,0xeb,
  0x64,0x55,0x60,0xdc
};

uint8_t Spuk1024dev[] =
{
  0x01,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x03,0x00,0x00,0x00,0x31,0x6E,0xC6,0x4F,
  0xF1,0xE8,0x7D,0x81,0x38,0x6D,0xD8,0xB3,0x2B,0xE4,0xB5,0xA0,0x09,0xAF,0x74,0xDD,
  0xE9,0x60,0x27,0x42,0x07,0xA3,0xAC,0xEF,0xE5,0x75,0x07,0xA8,0xC2,0x2C,0x25,0x56,
  0x91,0x37,0xEA,0xDB,0xDB,0x68,0x4A,0x1C,0xE3,0x29,0x61,0x85,0xD7,0xD8,0x66,0x86,
  0x66,0xBF,0xBF,0x98,0xAE,0xB4,0xE9,0x6C,0x13,0x81,0x97,0x78,0x2A,0x8D,0xDC,0x37,
  0x9A,0xF1,0xA4,0x0A,0x9D,0x74,0xD5,0x72,0xBC,0xB5,0x64,0xA6,0x1A,0x62,0xD5,0x39,
  0xFB,0x6F,0xC0,0xD1,0xC7,0x93,0xC3,0x20,0xDA,0x84,0x69,0x1E,0xD9,0x96,0x2E,0xC1,
  0x4F,0x28,0x96,0x14,0xA4,0x68,0x0A,0x40,0xE5,0x17,0xE7,0xD6,0x76,0x4D,0x81,0xD8,
  0xD2,0xA6,0x18,0x82,0x36,0x40,0x97,0x31,0xD9,0x88,0xDF,0xAF,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x3A,0x4B,0x4E,
  0x1B,0x4A,0x76,0x6F,0xB9,0x6C,0x18,0x5D,0xD5,0x98,0xF0,0xF1,0xBE,0x0A,0xD9,0x57,
  0x85,0xC6,0xC9,0x63,0xB3,0xF5,0x21,0x26,0x07,0xBA,0x6A,0x05,0xFB,0x5A,0x06,0x87,
  0x2A,0x30,0x3F,0xA9,0xEA,0xAB,0x0E,0x50,0x70,0x3B,0x7E,0xD4,0xD2,0x8C,0xF3,0xA1,
  0xCF,0x9A,0x6C,0x6B,0xCF,0x9B,0x1B,0x2A,0x97,0x6A,0x3C,0x38,0x40,0x43,0xB1,0x97,
  0x19,0x07,0x64,0x11,0x94,0x73,0x14,0xC9,0xA3,0xFE,0x7F,0xF6,0x64,0x23,0x73,0xE3,
  0x76,0xCE,0xF7,0xF4,0x2F,0x6C,0x9D,0x0A,0xF6,0x39,0xE6,0x1D,0xB2,0x17,0x29,0x39,
  0x98,0x52,0xDA,0xE0,0x31,0xA1,0xFA,0x85,0x52,0xC2,0x60,0xB5,0x11,0x42,0xC6,0x9B,
  0x55,0xD8,0x40,0x37,0xF7,0xDB,0x01,0x6A,0xD5,0x26,0x3B,0x27,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
uint8_t Cprk1024dev[]={
  0xB2,0x78,0xBE,0x1C,0x97,0xF5,0x9A,0xB4,0x94,0xDD,0x93,0xF1,0x39,0x6D,0xE8,0x5C,
  0x69,0x08,0x1A,0xC8,0x01,0x00,0x00,0x00,0xDD,0xCC,0xBB,0xAA,0x00,0x04,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x8F,0x20,0xA0,0xBE,0x36,0xEF,0x7F,0x3C,0xD9,0x6D,0x08,0xD0,0xF9,0xB6,0x7E,0x26,
  0xF2,0x01,0x90,0x6C,0xA0,0x1E,0x28,0xA1,0x35,0xAE,0xCF,0x97,0x33,0x49,0x74,0x11,
  0x40,0x11,0xB4,0x5C,0x29,0xCB,0x7E,0x9A,0x6C,0xC6,0xAF,0x21,0x78,0x59,0x25,0x9C,
  0x33,0x90,0x8B,0x29,0xB4,0xC1,0xE6,0x00,0x9B,0xF2,0x42,0x93,0xAA,0xC1,0xD1,0x46,
  0x33,0x47,0x67,0x09,0x98,0xDA,0x36,0x7F,0x2B,0x0D,0x96,0x5F,0xDC,0x08,0x89,0x3F,
  0xAE,0x27,0x8C,0xD0,0xE8,0x98,0x6A,0xA0,0x10,0xD3,0x1F,0x79,0x84,0x8F,0xD5,0x67,
  0xC3,0x0F,0xD3,0xC4,0xD5,0xFA,0x81,0x51,0xB5,0x23,0x80,0xBA,0x95,0xEE,0x54,0xAA,
  0x29,0x0B,0x01,0x0D,0x62,0xC4,0x60,0xA6,0x5A,0x31,0x44,0x0D,0x80,0xB5,0x33,0x43,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xD6,0xB0,0xF1,0x1D,0x52,0x67,0x3E,0xDB,0x46,0x23,0x8D,0x39,0x76,0x91,0xBD,0x3A,
  0x6B,0x02,0x58,0xA2,0xF0,0x2D,0x3C,0xF1,0xD0,0x86,0x37,0x62,0xCC,0xEE,0x2E,0x19,
  0xE0,0x1A,0x8E,0x8A,0x3E,0xB1,0x3D,0xE7,0xA3,0x2A,0x06,0xB2,0x34,0x85,0xB8,0x6A,
  0x4D,0x58,0xD0,0xBE,0x8F,0x22,0xD9,0x00,0xE9,0xEB,0x63,0xDD,0x80,0x22,0xB9,0xEB,
  0x21,0xFF,0x20,0x7B,0x4B,0x0A,0x94,0xAF,0x14,0xA5,0x95,0x07,0x54,0xCB,0x5E,0x61,
  0x26,0x8A,0xB8,0xCA,0x3E,0xFF,0x97,0x33,0xD3,0xA5,0x13,0xD7,0x6E,0x9E,0xF5,0xEA,
  0xCF,0x49,0x44,0xFE,0xB0,0x97,0x76,0xA8,0x10,0x78,0x08,0x80,0xB3,0x5F,0x21,0x13,
  0xF0,0x41,0x7A,0x2E,0x99,0x8A,0xED,0x62,0xC8,0xB2,0x9D,0xC3,0xFA,0xC6,0x5E,0x71,
  0x81,0x49,0x92,0x11,0x56,0x71,0x3E,0x6A,0x2E,0x83,0xC4,0x30,0xFD,0xE1,0x40,0x75,
  0x43,0x64,0x8E,0x1F
};

uint8_t Cpuk1024dev[]={
  0x01,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x03,0x00,0x00,0x00,0x71,0x5E,0xC6,0xFA,
  0xC3,0x9D,0xB2,0xC8,0x62,0xED,0x8A,0x99,0x2E,0x7A,0x41,0xF0,0x13,0x21,0x5F,0xB3,
  0x80,0x08,0x78,0x10,0xA8,0x76,0x97,0xB0,0xFE,0x44,0x49,0xCF,0xEA,0xF5,0x9E,0x6E,
  0xD7,0x13,0xA5,0xD3,0x33,0x97,0xFF,0x3E,0xCA,0xB8,0x8A,0x26,0x61,0x5E,0xCB,0x54,
  0x07,0x95,0xA5,0x14,0xAF,0x94,0x0A,0x4B,0x7B,0x20,0xFF,0x21,0xEB,0xB9,0x22,0x80,
  0xDD,0x63,0xEB,0xE9,0x00,0xD9,0x22,0x8F,0xBE,0xD0,0x58,0x4D,0x6A,0xB8,0x85,0x34,
  0xB2,0x06,0x2A,0xA3,0xE7,0x3D,0xB1,0x3E,0x8A,0x8E,0x1A,0xE0,0x19,0x2E,0xEE,0xCC,
  0x62,0x37,0x86,0xD0,0xF1,0x3C,0x2D,0xF0,0xA2,0x58,0x02,0x6B,0x3A,0xBD,0x91,0x76,
  0x39,0x8D,0x23,0x46,0xDB,0x3E,0x67,0x52,0x1D,0xF1,0xB0,0xD6,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xEB,0xCE,0xB0,0x37,
  0x5B,0x64,0xB1,0x4A,0xAF,0x1B,0x9C,0x45,0x66,0x80,0x58,0xF1,0x88,0x0C,0x7E,0x20,
  0xF4,0x71,0x5C,0x0A,0xD6,0x32,0xA4,0x03,0xAB,0xD3,0xE9,0xBF,0xE1,0xB3,0x50,0x46,
  0xFE,0x94,0xAB,0x31,0x4A,0x90,0xB3,0xC0,0xB9,0x0E,0x76,0x58,0x6A,0x6A,0x73,0x53,
  0xE0,0x8D,0x5C,0x16,0x46,0xB2,0xB1,0x6F,0x94,0x42,0x61,0x83,0x04,0x13,0x00,0x87,
  0xB4,0x59,0x74,0xF9,0x07,0xF1,0x73,0x5F,0x22,0xF5,0xB0,0xBC,0xE5,0x29,0x4C,0xF9,
  0x92,0x11,0xF4,0xE3,0xEF,0x69,0x75,0xD3,0x95,0xE3,0xE2,0x4A,0x89,0x6B,0x8E,0x38,
  0x71,0x7D,0x33,0xAB,0x08,0xDB,0x6F,0xE1,0x49,0x7F,0xD1,0x4A,0x51,0x7B,0x3F,0x0C,
  0xCA,0xA5,0xE6,0x5D,0x3E,0x59,0xC5,0x8B,0xB3,0xDB,0xA3,0x92,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
  };
#endif /* SIERRA_CTF */
/* SWISTOP */

/*==========================================================================*/
/*===========================                    ===========================*/
/*======================    GENEREL SECURE FUNCTIONS      ==================*/
/*===========================                    ===========================*/
/*==========================================================================*/
//lint -esym(429,tmp_elm)
// Reviewed 17-Jun-2013. The memory allocated to tmp_elm is freed in another scope
uint32_t sec_generate_cert_block(T_SEC_CERT_BLOCK type_id, size_t *data_length, uint8_t **data_ptr_ptr)
{
  uint16_t curr_offset = 0;
  T_SECCH_LIST_ELM *curr_list_elm = NULL;
  uint16_t cert_tot_len = 0;
  T_SECCH_LIST_ELM *tmp_elm = NULL;
  uint32_t id_idx = 0;
  uint32_t result = SECURE_CH_RES_SUCCESS;

  switch(type_id)
  {
    case SEC_CERT_INJECT:
    {
      // Parse for certificate type
      for(id_idx = 0; id_idx<CERT_BLK_INFO_NOF_ELEMENTS; id_idx++)
      {
        if(!memcmp((uint8_t *)&(CERT_BLK_INFO[id_idx].cert_tlv.root_id),&(*data_ptr_ptr)[CERT_BLK_INFO[id_idx].cert_tlv.root_offset], CERT_BLK_INFO[id_idx].cert_tlv.root_size))
        {
          break;
        }
      }

      // See if certificate data was recognized
      if(CERT_BLK_INFO_NOF_ELEMENTS == id_idx)
      {
        result = SECURE_CH_RES_ERROR;
        goto error;
      }

      // Set flags accordingly
      switch(CERT_BLK_INFO[id_idx].cert_tlv.root_id)
      {
        case MID_GRP_TYPE:
          if(true == mid_cert_present)
          {
            goto error;
          }
          else
          {
            mid_cert_present = true;
          }
          break;
        case RND_GRP_TYPE:
          if(true == rnd_cert_present)
          {
            goto error;
          }
          else
          {
            rnd_cert_present = true;
          }
          break;
        case KEY_CERT_ROOT:
          if(true == key_cert_present)
          {
            goto error;
          }
          else
          {
            key_cert_present = true;
          }
          break;
      }

      // Allocate list element
      if(NULL == (tmp_elm = (T_SECCH_LIST_ELM *)malloc(sizeof(T_SECCH_LIST_ELM))))
      {
        result = SECURE_CH_RES_MALLOC_FAILED;
        goto error;
      }

      if(NULL == (tmp_elm->certificate.data = (uint8_t *)malloc(*data_length)))
      {
        result = SECURE_CH_RES_MALLOC_FAILED;
        goto error;
      }

      tmp_elm->next_elem=cert_list_header;

      // Set data parameters
      tmp_elm->certificate.flash_tlv_id = CERT_BLK_INFO[id_idx].flash_tlv_id;
      memcpy(tmp_elm->certificate.data,*data_ptr_ptr,*data_length);
      tmp_elm->certificate.length = *data_length;

      // Update current list element with the new next element
      cert_list_header = tmp_elm;

      break;
    }
    case SEC_CERT_AREA_READ:
    {
      // Nothing to prepend (Disabling cert block)
      if (NULL == cert_list_header)
      {
        *data_ptr_ptr=NULL;
        *data_length=0;
        break;
      }

      curr_list_elm = cert_list_header;

      cert_tot_len = 2*sizeof(uint32_t) + 2*sizeof(uint32_t); // flash block group and length + cert block group and length

      // Find length of certificates in linked list + add their tlv elements (=2 x uint8_t)
      while(NULL != curr_list_elm)
      {
        if(curr_list_elm->certificate.data)
        {
          cert_tot_len += curr_list_elm->certificate.length + 2*sizeof(uint32_t); // binary length + tlv field lengths
        }
        curr_list_elm = curr_list_elm->next_elem;
      }

      // Allocate buffer for entire certificate TLV block
      if(NULL == (glob_all_cert = (uint8_t *)malloc(cert_tot_len)))
      {
        result = SECURE_CH_RES_MALLOC_FAILED;
        goto error;
      }

      //Build beginning of certificate block
      LIT_UINT32_TO_UCHARS(&glob_all_cert[0],FLASH_BLOCK_GROUP);
      LIT_UINT32_TO_UCHARS(&glob_all_cert[4],cert_tot_len - sizeof(uint32_t)*2);
      LIT_UINT32_TO_UCHARS(&glob_all_cert[8],CERT_BLOCK_GROUP);
      LIT_UINT32_TO_UCHARS(&glob_all_cert[12],cert_tot_len - sizeof(uint32_t)*4);

      // Set offset to start from + point to first cert in list
      curr_offset = sizeof(uint32_t)*4;
      curr_list_elm = cert_list_header;

      // Insert certificates. We assume at this point that no duplicates exist
      while(NULL != curr_list_elm)
      {
        if(curr_list_elm->certificate.data)
        {
          LIT_UINT32_TO_UCHARS(&glob_all_cert[curr_offset],curr_list_elm->certificate.flash_tlv_id);
          curr_offset += sizeof(uint32_t);
          LIT_UINT32_TO_UCHARS(&glob_all_cert[curr_offset],curr_list_elm->certificate.length);
          curr_offset += sizeof(uint32_t);
          memcpy(&glob_all_cert[curr_offset],curr_list_elm->certificate.data,curr_list_elm->certificate.length);
          curr_offset += curr_list_elm->certificate.length;
        }
        curr_list_elm = curr_list_elm->next_elem;
      }

      *data_ptr_ptr=glob_all_cert;
      *data_length=cert_tot_len;

      break;
    }
    case SEC_CERT_AREA_FREE:
    {
      T_SECCH_LIST_ELM *local_curr_list_elm = cert_list_header;
      T_SECCH_LIST_ELM *next_elm = NULL;

      // Run through linked list while freeing elements
      while(NULL != local_curr_list_elm)
      {

        if(local_curr_list_elm->certificate.data)
        {
          free(local_curr_list_elm->certificate.data);
        }

        next_elm = local_curr_list_elm->next_elem;
        free(local_curr_list_elm);
        local_curr_list_elm = next_elm;
      }

      // Reset first list element
      cert_list_header = NULL;

      // Free flash TLV block
      if(glob_all_cert)
      {
        free(glob_all_cert);
        glob_all_cert = NULL;
      }

      //Reset certificate flags
      mid_cert_present = false;
      rnd_cert_present = false;
      key_cert_present = false;
      break;
    }
  }

  error:

  return result;
}
//lint +esym(429,tmp_elm)

/* SWISTART */
#ifndef SIERRA_CTF
/*==========================================================================*/
/*===========================                    ===========================*/
/*======================    SECURE CHANNEL FUNCTIONS      ==================*/
/*===========================                    ===========================*/
/*==========================================================================*/

/*******************************************************************************
* Function:... sec_ch_setup
*******************************************************************************/
uint32_t sec_ch_setup(uint32_t options, char ** cert_files)
{
  uint32_t result = SECURE_CH_RES_SUCCESS;
//  T_SECCH_LIST_ELM *curr_list_elm = NULL;
  uint32_t i = 0;
  FILE *file_ptr = NULL;

  // Check input parameters
  if(NULL == cert_files)
  {
    // Valid case - Nothing to do. (SMS04492604)
    // result = SECURE_CH_RES_INVALID_PARAM;
    goto error;
  }

  // Save options parameter
  glob_options_param = options;

  // Setup linked list pointer
//  curr_list_elm = &cert_list_header;

  // Run through list of files to load
  for(i=0; NULL != cert_files[i]; i++)
  {
    size_t file_size = 0;
    uint8_t *data_buffer = NULL;

    // Open file
    file_ptr = fopen(cert_files[i],"rb");
    if(NULL == file_ptr)
    {
      result = SECURE_CH_RES_FILE_ERROR;
      goto error;
    }

    // Get file size
    fseek (file_ptr, 0 , SEEK_END);
    file_size = ftell(file_ptr);
    rewind (file_ptr);

    // Check file_size limits
    if(0 >= file_size || 4096 <= file_size)
    {
      fclose(file_ptr);
      result = SECURE_CH_RES_FILE_ERROR;
      goto error;
    }

    // Allocate data buffer
    if(NULL == (data_buffer = (uint8_t *)malloc(file_size)))
    {
      fclose(file_ptr);
      result = SECURE_CH_RES_MALLOC_FAILED;
      goto error;
    }

    // Now read in the file.
    if(file_size != fread(data_buffer,1,file_size,file_ptr))
    {
      fclose(file_ptr);
      free(data_buffer);
      result = SECURE_CH_RES_FILE_ERROR;
      goto error;
    }

    if(SECURE_CH_RES_SUCCESS != (result = sec_generate_cert_block(SEC_CERT_INJECT, &file_size,&data_buffer)))
    {
      fclose(file_ptr);
      free(data_buffer);
      goto error;
    }

    free(data_buffer);

    if(EOF == fclose(file_ptr))
    {
      result = SECURE_CH_RES_FILE_ERROR;
      goto error;
    }
    file_ptr=NULL;

  }

  // Everything went well
  result = SECURE_CH_RES_SUCCESS;
  goto cleanup;

  // A fatal error requires all data to be freed and reset
  error:
  {
    sec_generate_cert_block(SEC_CERT_AREA_FREE,NULL,NULL);
  }

  cleanup:
  //Close file again


  return result;
}

/*******************************************************************************
* Function:... sec_ch_callback
*******************************************************************************/
uint32_t sec_ch_callback(uint32_t *data_type, size_t *data_length, uint8_t **data_ptr_ptr)
{
  uint32_t result = SECURE_CH_RES_SUCCESS;

  // Check input parameters
  if(NULL == data_length || NULL == data_ptr_ptr)
  {
    result = SECURE_CH_RES_INVALID_PARAM;
    goto error;
  }

  //Evaluate action
  switch(*data_type)
  {
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  case SECURE_CH_DATA_SNUM:
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  {

    // Find out if key_cert has to be generated
    if(false == key_cert_present)
    {
      T_SIGN_CONTEXT sign_ctx;
      T_LOG_CONTEXT log;
      T_HW_DETAILS hw_details;
      uint32_t key_cert_len = 0;
      uint8_t bind_to_hwid = 0;

      Debug("Key cert not present");


      // Setup signing module context
      sign_ctx.log = &log;
      log.log_lowlevel = stdout;
      log.log_highlevel = stdout;

      // Reset HW details (SNUM is only needed with updated signing module)
      memset((void*)&hw_details,0x00,sizeof(hw_details));

      // Check if SNUM was provided and length is correct
      if(NULL == *data_ptr_ptr || 3*sizeof(uint32_t) != *data_length)
      {
        result = SECURE_CH_RES_INVALID_PARAM;
        goto error;
      }
      else // could be optional
      {
        result = SECURE_CH_RES_INVALID_PARAM;
        memcpy(&hw_details.hwid_baseband,*data_ptr_ptr,*data_length);
        bind_to_hwid = 1;
      }

      //Allocate data buffer
      if(NULL == (glob_key_cert = (uint8_t *)malloc(SEC_MAX_SIZE_KEY_CERT)))
      {
        result = SECURE_CH_RES_MALLOC_FAILED;
        goto error;
      }

      // Setup signing module context with default private key
      if(false == SIGN_create_context(&sign_ctx,&hw_details,(T_PRIVATE_KEY*)Sprk1024dev))
      {
        result = SECURE_CH_RES_SIGNMOD_ERROR;
        goto error;
      }

      // Request a key certificate generated by signing module
      if(false == SIGN_make_key_certificate(&sign_ctx,bind_to_hwid,NULL,0,(T_PUBLIC_KEY *)Cpuk1024dev,sizeof(Cpuk1024dev),keyswap_list,sizeof(keyswap_list),glob_key_cert,&key_cert_len,SEC_MAX_SIZE_KEY_CERT))
      {
        result = SECURE_CH_RES_SIGNMOD_ERROR;
        goto error;
      }

      if(false == SIGN_delete_context(&sign_ctx))
      {
        result = SECURE_CH_RES_SIGNMOD_ERROR;
        goto error;
      }

      //Set return values
      *data_ptr_ptr = glob_key_cert;
      *data_length = key_cert_len;
    }
    else
    {
      Debug("Key cert present");
      //Set return values
      *data_ptr_ptr = NULL;
      *data_length = 0;
    }

    *data_type = SECURE_CH_DATA_REPLY;
    break;
  }
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  case SECURE_CH_DATA_REQ:
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  {
    uint16_t temp_u16 = 0;
    uint16_t *container_type = 0;
    uint16_t *container_length = 0;
    uint32_t idx = 0;
    uint32_t sign_len = ((T_PRIVATE_KEY*)Cprk1024dev)->Key.KeyLength/8;
    uint32_t reply_len = sizeof(uint32_t);
    uint32_t reply_data_len = (SEC_CHANNEL_HEADER_SIZE + //signed data group
                               SEC_CHANNEL_HEADER_SIZE + //hash TLV fields
                               crypto_sw_hash_get_size(CM_SHA2) +
                               SEC_CHANNEL_HEADER_SIZE + //request ID TLV fields
                               sizeof(UtaSecChannelReqId) +
                               SEC_CHANNEL_HEADER_SIZE + //reply data group
                               SEC_CHANNEL_HEADER_SIZE + //version reply group
                               SEC_CHANNEL_HEADER_SIZE + //version reply group
                               reply_len +
                               SEC_CHANNEL_HEADER_SIZE + //signature TLV fields
                               sign_len );
    T_SW_HASH_CONTEXT context;
    UtaSecChannelReqId request_id = UTA_SEC_VERSION_VALIDATE;

    // Read container TLV info
    container_type=(uint16_t * )&(*data_ptr_ptr)[0];
    container_length=(uint16_t *)&(*data_ptr_ptr)[2];

    // Check request header
    if((uint16_t)UTA_SEC_SECURE_CHANNEL_REQ != *container_type)
    {
      result = SECURE_CH_RES_INVALID_REQ_ID;
      goto error;
    }

    // Allocate buffer for secure channel reply package
    if(NULL == (glob_reply_data = (uint8_t *)malloc(2*SEC_CHANNEL_HEADER_SIZE + reply_data_len)))
    {
      result = SECURE_CH_RES_MALLOC_FAILED;
      goto error;
    }

    // Build Secure Channel TLV reply (indentation given for better overview)
    // ----------------------------------------------------------------------------------------------
    // Add secure channel reply main group
    LIT_UINT16_TO_UCHARS(&glob_reply_data[idx],(uint16_t)UTA_SEC_SECURE_CHANNEL_REPLY);
    LIT_UINT16_TO_UCHARS(&glob_reply_data[(uint32_t)(idx+2)],reply_data_len);
    idx += SEC_CHANNEL_HEADER_SIZE;

      // Add signed data group
      LIT_UINT16_TO_UCHARS(&glob_reply_data[idx],(uint16_t)UTA_SEC_SIGNED_DATA);
      temp_u16 = (uint16_t)(3*SEC_CHANNEL_HEADER_SIZE+crypto_sw_hash_get_size(CM_SHA2)+sizeof(UtaSecChannelReqId)+reply_len+2*SEC_CHANNEL_HEADER_SIZE);
      LIT_UINT16_TO_UCHARS(&glob_reply_data[(uint32_t)(idx+2)],temp_u16);
      idx += SEC_CHANNEL_HEADER_SIZE;

        // Add hash TLV fields
        temp_u16 = (uint16_t)UTA_SEC_HASH_SHA256;
        LIT_UINT16_TO_UCHARS(&glob_reply_data[idx], temp_u16);
        temp_u16 = (uint16_t)crypto_sw_hash_get_size(CM_SHA2);
        LIT_UINT16_TO_UCHARS(&glob_reply_data[(uint32_t)(idx+2)],temp_u16);
        idx += SEC_CHANNEL_HEADER_SIZE;
        // Add hash
        crypto_sw_hash_init(&context,CM_SHA2);
        crypto_sw_hash_update(&context,(uint8_t *)&(*data_ptr_ptr)[4],(uint32_t )*container_length);
        crypto_sw_hash_final(&context,(uint8_t *)&glob_reply_data[idx]);
        idx += crypto_sw_hash_get_size(CM_SHA2);

        // Add request ID TLV fields
        temp_u16 = (uint16_t)UTA_SEC_REQ_ID;
        LIT_UINT16_TO_UCHARS(&glob_reply_data[idx],temp_u16);
        temp_u16 = sizeof(UtaSecChannelReqId);
        LIT_UINT16_TO_UCHARS(&glob_reply_data[(uint32_t)(idx+2)],temp_u16);
        idx += SEC_CHANNEL_HEADER_SIZE;
        // Add request ID
        memcpy((void*)&glob_reply_data[idx],(const void*)&request_id,sizeof(UtaSecChannelReqId));
        idx += sizeof(UtaSecChannelReqId);

        // Add reply data group
        temp_u16 = (uint16_t)UTA_SEC_REPLY_DATA;
        LIT_UINT16_TO_UCHARS(&glob_reply_data[idx],temp_u16);
        LIT_UINT16_TO_UCHARS(&glob_reply_data[(uint32_t)(idx+2)],2*SEC_CHANNEL_HEADER_SIZE + reply_len);
        idx += SEC_CHANNEL_HEADER_SIZE;

          // Add version reply group
          temp_u16 = (uint16_t)UTA_SEC_SYS_VERSION_VAL_REPLY;
          LIT_UINT16_TO_UCHARS(&glob_reply_data[idx],temp_u16);
          LIT_UINT16_TO_UCHARS(&glob_reply_data[(uint32_t)(idx+2)],SEC_CHANNEL_HEADER_SIZE + reply_len);
          idx += SEC_CHANNEL_HEADER_SIZE;

            // Add version verdict TLV fields
            temp_u16 = (uint16_t)UTA_SEC_SYS_VERSION_SW_VERSION_VERDICT;
            LIT_UINT16_TO_UCHARS(&glob_reply_data[idx],temp_u16);
            LIT_UINT16_TO_UCHARS(&glob_reply_data[(uint32_t)(idx+2)],reply_len);
            idx += SEC_CHANNEL_HEADER_SIZE;
            // Add version verdict
            temp_u16 = (uint32_t)UTA_SEC_SYS_VERSION_SW_VERSION_BOOT;
            LIT_UINT32_TO_UCHARS(&glob_reply_data[idx],temp_u16);
            idx += reply_len;

      // Add signature group
      temp_u16 = (uint16_t)UTA_SEC_SIGNATURE;
      LIT_UINT16_TO_UCHARS(&glob_reply_data[idx],temp_u16);
      LIT_UINT16_TO_UCHARS(&glob_reply_data[(uint32_t)(idx+2)],sign_len);
      idx+=SEC_CHANNEL_HEADER_SIZE;

      // Add signature
      {
        T_SIGN_CONTEXT sign_ctx;
        T_LOG_CONTEXT log;
        T_HW_DETAILS hw_details;
        uint8_t signature[256];
        uint32_t signature_len = 0;

        // Setup signing module context
        sign_ctx.log = &log;
        log.log_lowlevel = stdout;
        log.log_highlevel = stdout;

        // Reset HW details (SNUM is only needed with updated signing module)
        memset((void*)&hw_details,0x00,SEC_HWID_SIZE);

        // Setup signing module context with default private key
        if(false == SIGN_create_context(&sign_ctx,&hw_details,(T_PRIVATE_KEY*)Cprk1024dev))
        {
          result = SECURE_CH_RES_SIGNMOD_ERROR;
          goto error;
        }

        // Generate signature based on signed data
        if(false == SIGN_make_generic_signature(&sign_ctx,0x01,true,(uint8_t)SHA256,
                      (uint8_t *)&glob_reply_data[2*SEC_CHANNEL_HEADER_SIZE],LIT_UCHARS_TO_UINT16(&glob_reply_data[SEC_CHANNEL_HEADER_SIZE+2]),signature,&signature_len,SEC_MAX_SIZE_SIGNATURE))
        {
          result = SECURE_CH_RES_SIGNMOD_ERROR;
          goto error;
        }

        if(false == SIGN_delete_context(&sign_ctx))
        {
          result = SECURE_CH_RES_SIGNMOD_ERROR;
          goto error;
        }

        // Copy signature (actual size) to reply package
        memcpy((uint8_t *)&glob_reply_data[idx],signature,sign_len);
      }

    // Update output parameters
    *data_type = SECURE_CH_DATA_REPLY;
    *data_length = 2*SEC_CHANNEL_HEADER_SIZE + reply_data_len;
    *data_ptr_ptr = (uint8_t *)glob_reply_data;
    break;
  }
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  case SECURE_CH_DATA_FREE_RETURN_DATA:
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  {
    // Free secure channel key
    if(glob_key_cert)
    {
      free(glob_key_cert);
      glob_key_cert = NULL;
    }

    // Free secure channel reply package
    if(glob_reply_data)
    {
      free(glob_reply_data);
      glob_reply_data = NULL;
    }

    break;
  }
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  default:
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  {
    goto error;
  }
  }

  // Everything went well
  result = SECURE_CH_RES_SUCCESS;
  goto cleanup;

  // A fatal error requires all data to be freed and reset
  error:
  {
    uint32_t cb_type = SECURE_CH_DATA_FREE_RETURN_DATA;
    sec_ch_callback(&cb_type,NULL,NULL);
  }

  cleanup:
  return result;
}

/*--------------------------------------------------------------------------------------*/

#endif /* SIERRA_CTF */
/* SWISTOP */

